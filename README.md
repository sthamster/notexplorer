Nevoton\'s OpenTherm Explorer
===

NOTExplorer.py - утилита, позволяющая поэкспериментировать с взаимодействием по протоколу [Opentherm](https://ihormelnyk.com/Content/Pages/opentherm_library/Opentherm%20Protocol%20v2-2.pdf) между модулем шлюза, [выпускаемым компанией Невотон](https://nevoton.ru/product/modul-rasshireniya-opentherm-dlya-wiren-board-6/), и вашим котлом, поддерживающим этот протокол. Утилита предоставляет упрощённый интерфейс взаимодействия, автоматизирует рутинные операции (такие, как повторение команды в случае ошибки), и преобразует данные человеческого формата в/из формат(а) протокола Opentherm.

Утилита работает в среде контроллера [WirenBoard](https://wirenboard.com) (разрабатывалась и тестировалась на WirenBoard 6), и требует для своей работы интерпретатор Python3 (предпочтительно 3.5), и библиотеки paho-mqtt (для работы через mqtt) и pymodbus (для работы через serial/modbusRTU интерфейс). Питон на WB, как правило, уже стоит, а библиотеки можно поставить через pip или командами `apt-get install python3-paho-mqtt` и `apt-get install python3-pymodbus`. Выбор интерфейса зависит от того, запущен/работает ли в системе драйвер wb-mqtt-serial, сконфигурированный на поддержку вашего WBE2-I-OPENTHERM устройства. Если драйвер работает, необходимо использовать утилиту с mqtt интерфейсом, иначе - с serial/modbusRTU.

Выбор интерфейса производится ключами `-t` и `-m`. В первом случае выбирается mqtt интерфейс, и необходимо указать после ключа mqtt идентификатор вашего устройства (например, `-t wbe2-i-opentherm_11`), а во втором - имя устройства последовательного интерфейса, через которое подключен ваш шлюз (например, `-m /dev/ttyMOD1`). Опционально указываются параметры подключения к mqtt-брокеру и идентификатор modbus устройства.

**Внимание!** При использовании интерфейса последовательного доступа (ключ `-m`) соответствующее устройство не должно использоваться штатным шлюзом mqtt<->serial (т.е., например, `fuser -v /dev/ttyMOD1` не должен показывать процесса wb-mqtt-serial). Ну и наоборот, если вы хотите использовать mqtt интерфейс, убедитесь, что штатный шлюз надлежащим образом сконфигурирован и ваше устройство доступно через стандартный веб-интерфейс WirenBoard (который, в свою очередь, пользуется шлюзом wb-mqtt-serial).

Утилита реализует команды:  
`read <data-id>[/<data-value>]` - чтение ячейки ведомого устройства (если чтение предусматривает одновременную передачу данных в котёл, они указываются через прямой слэш)  
`write <data-id> <data-value>` - запись ячейки ведомого устройства  
`readtsp <paramStart>[-<ParamFinish>]` - чтение "прозрачного" параметра котла (Transparent Slave Parameter (TSP))  
`writetsp <paramN> <ParamValue>` - запись "прозрачного" параметра котла  
`readerr <errN>` - чтение записи из истории сбоев (Fault-History-Buffer (FHB))  
`scan` - чтение всех известных программе ячеек opentherm ведомого устройства  
`fullscan [<start-id>[-<finish-id>]]` - сплошное чтение всех ячеек opentherm ведомого устройства  
`cmd` - запуск утилиты в интерактивном режиме, при котором можно выполнять индивидуальные команды, описанные выше, без переинициализации интерфейса  

Команду можно сокращать до первой буквы (`r` вместо `read` и т.д., кроме `readtsp`, `writetsp` и `readerr` которым соответствуют `rt`, `wt` и `re`)  
Все команды, кроме `cmd`, `scan` и `fullscan` можно задавать в командной строке несколько раз, в любой последовательности  

При задании ключа `-v` (а также при запуске в интерактивном режиме), утилита выводит на экран подробности выполняемых операций, и декодирует считанные из ячеек opentherm данные в человекочитаемый формат.  

При выполнении команды `write` (и чтении нулевой ячейки) можно использовать суффиксы форматирования, для преобразования указанных данных в формат, специфичный для конкретной ячейки opentherm. Например:  
`write 8 12.5%F8.8` - запись в восьмую ячейку рационального числа 12.8 (что, в формате opentherm F8.8, эквивалентно записи 16-битного числа 3200; для отрицательных чисел вместо '-' используйте '~')  
или `write 126 3%HB0` - запись в 126-ю ячейку числа 3 в старший байт (а точнее, начиная с бита 0 старшего байта, что эквивалентно записи 16-битного числа 768)  
или `read 0/1%HB0+1%HB3` - чтение ячейки 0 с передачей установленных битов 0 и 3 старшего байта (что эквивалентно чтению с передачей 16-битного значения 2304)  

При задании ключа `-r` утилита будет пытаться повторить (до трёх раз, если ключ дан без значение, или заданное количество) команду, если при её выполнении возникла устранимая ошибка.  

При задании ключа `-l` утилита будет писать протокол своей работы в указанный лог-файл, а при указании, дополнительно, ключа `-d` этот протокол будет содержать много отладочной информации.  


Примеры использования:  

Чтение ячейки конфигурации котла (DATA-ID 3) через MQTT интерфейс из устройства `wbe2-i-opentherm_11`  
`./NOTExplorer.py -t wbe2-i-opentherm_11 read 3`

Сброс блокировки котла через MQTT интерфейс (запись 1 в старший байт ячейки с DATA-ID 4, (с повтором команды в случае ошибки, с логированием отладочной информации в файл 'log' и выводом подробностей обмена)  
`./NOTExplorer.py -t wbe2-i-opentherm_11 -r -l log -d -v write 4 1%HB0`

Выдача устройству с modbus идентификатором 11 через последовательный интерфейс `/dev/ttyMOD1` последовательности команд на: запись через opentherm в ячейку 2 (котла) значения 27, чтение ячейки 0 с одновременной передачей установленных битов 0 и 3 старшего байта данных (состояние "CH enable" + "OTC active"), запись температуры 50 градусов в ячейку 1, чтение ячеек 3 и 5  (с повтором команд в случае ошибки и протоколированием в файл 'log')  
`./NOTExplorer.py -m /dev/ttyMOD1 -a 11 -r -l log w 2 27 r 0/1%HB0+1%HB3 w 1 50%F8.8 r 3 r 5`

Полное безусловное сканирование на чтение 255 opentherm ячеек котла (с повтором команды чтения два раза в случае ошибки, с логированием отладочной информации в файл 'fullscan.log' и выводом подробностей обмена)  
`./NOTExplorer.py -m /dev/ttyMOD1 -r 2 -l fullscan.log -d -v f 1-255`


P.S. Последняя версия программы доступна в https://github.com/sthamster/notexplorer  
P.P.S. Ну и, конечно, любопытные могут посмотреть в программе, в коде класса OTDecoder, инициализацию коллекции `self.otd`, где, собстенно, и сосредоточены основные знания по ячейкам opentherm устройств...  Это может быть особенно полезно, чтобы узнать формат данных, используемых в каждой конкретной ячейке, ибо не учитывая формат данных вы получите неправильные/непредсказуемые результаты.  

